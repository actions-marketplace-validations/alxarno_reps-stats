(()=>{"use strict";var e={956:function(e,n,t){var s=this&&this.__awaiter||function(e,n,t,s){return new(t||(t=Promise))((function(o,i){function r(e){try{a(s.next(e))}catch(e){i(e)}}function u(e){try{a(s.throw(e))}catch(e){i(e)}}function a(e){var n;e.done?o(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(r,u)}a((s=s.apply(e,n||[])).next())}))};Object.defineProperty(n,"__esModule",{value:!0}),n.CSVWriter=void 0;const o=t(917);n.CSVWriter=class{constructor(){}ToCSV(e){return s(this,void 0,void 0,(function*(){const n=new o(e);let t=yield n.toString(!0,!0);return console.log(t),Buffer.from(t,"utf8")}))}}},341:function(e,n,t){var s=this&&this.__awaiter||function(e,n,t,s){return new(t||(t=Promise))((function(o,i){function r(e){try{a(s.next(e))}catch(e){i(e)}}function u(e){try{a(s.throw(e))}catch(e){i(e)}}function a(e){var n;e.done?o(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(r,u)}a((s=s.apply(e,n||[])).next())}))};Object.defineProperty(n,"__esModule",{value:!0});const o=t(181),i=t(956),r=t(216),u=t(999);(function(){return s(this,void 0,void 0,(function*(){const e=u.getInput("token"),n=u.getInput("aws-access-key-id"),t=u.getInput("aws-secret-access-key"),s=u.getInput("aws-s3-bucket"),a=u.getInput("aws-s3-path"),l=u.getInput("org-name"),c=u.getInput("days")||1,d=u.getInput("stale")||0,g=u.getInput("old")||0;let h=new r.S3Dumper(n,t,s,a),p=new o.GithubScraper(e,l),f=new i.CSVWriter,m=new Date,I=new Date,C=m.toISOString().substring(0,19);I.setDate(m.getDate()-c),console.log(I,m);let y=yield p.scrape(I,m,d,g),v=yield f.ToCSV(y);return yield h.Write(v,`${C}.csv`),"Done good"}))})().then((e=>{console.log(`Finished running: ${e}`)}),(e=>{console.log(`ERROR ${e}`),process.exit(1)}))},216:function(e,n,t){var s=this&&this.__awaiter||function(e,n,t,s){return new(t||(t=Promise))((function(o,i){function r(e){try{a(s.next(e))}catch(e){i(e)}}function u(e){try{a(s.throw(e))}catch(e){i(e)}}function a(e){var n;e.done?o(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(r,u)}a((s=s.apply(e,n||[])).next())}))};Object.defineProperty(n,"__esModule",{value:!0}),n.S3Dumper=void 0;const o=t(336);n.S3Dumper=class{constructor(e,n,t,s){this.s3Client=null,this.bucket="",this.path="",this.s3Client=new o.S3({accessKeyId:e,secretAccessKey:n}),this.bucket=t,this.path=s}Write(e,n){return s(this,void 0,void 0,(function*(){let t=`${this.path}/${n}`;console.log(`Putting s3 object in bucket ${this.bucket}, path - ${t}`);const s={Bucket:this.bucket,Key:t,Body:e};yield new Promise(((e,n)=>{this.s3Client.putObject(s,(function(t,s){t?(console.error(t),n()):e(s)}))}))}))}}},181:function(e,n,t){var s=this&&this.__awaiter||function(e,n,t,s){return new(t||(t=Promise))((function(o,i){function r(e){try{a(s.next(e))}catch(e){i(e)}}function u(e){try{a(s.throw(e))}catch(e){i(e)}}function a(e){var n;e.done?o(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(r,u)}a((s=s.apply(e,n||[])).next())}))};Object.defineProperty(n,"__esModule",{value:!0}),n.GithubScraper=void 0;const o=t(142);n.GithubScraper=class{constructor(e,n){this.github_token=e,this.org=n,this.orgID=""}initAuthor(e,n){return n[e]={notSelfComments:0,selfComments:0,closedNotSelfIssues:0,closedSelfIssues:0,openAssignIssues:0,openAuthorIssues:0,oldIssues:0,staleIssues:0,codeLinesAdded:0,codeLinesRemoved:0},n}pullCommitsStatistics(e,n,t){return s(this,void 0,void 0,(function*(){let s=null,o=!1,i={},r=0;do{let u=yield e.graphql({query:'\n    query ($org: String! $repsPagination: String $since: GitTimestamp $until: GitTimestamp) {\n      organization(login: $org ) {\n        repositories(first: 5, after: $repsPagination) {\n          nodes {\n            refs(refPrefix: "refs/heads/", orderBy: {direction: DESC, field: TAG_COMMIT_DATE}, first: 15) {\n              edges {\n                node {\n                  ... on Ref {\n                    name\n                    target {\n                      ... on Commit {\n                        history(first: 100, since: $since, until: $until) {\n                          edges {\n                            node {\n                              ... on Commit {\n\n                                committedDate\n                                author{\n                                  user {\n                                    login\n                                  }\n                                }\n                                deletions\n                                additions\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          pageInfo {\n            hasNextPage\n            endCursor\n          }\n        }\n      }\n    }',repsPagination:s,since:n,until:t,org:this.org});u.organization.repositories.nodes.forEach((e=>{e.refs.edges.forEach((e=>{e.node.target.history.edges.forEach((e=>{let s=e.node,o=Date.parse(s.committedDate);if(null==s.author.user)return;let r=s.author.user.login;o<n.getTime()||o>t.getTime()||(r in i||(i=this.initAuthor(r,i)),i[r].codeLinesAdded+=s.additions,i[r].codeLinesRemoved+=s.deletions)}))}))})),u.organization.repositories.pageInfo.hasNextPage?s=u.organization.repositories.pageInfo.endCursor:o=!0,r+=u.organization.repositories.nodes.length}while(!o);return console.log(`Commits statistics processed ${r} repositories`),i}))}pullOpenIssuesStatistics(e,n,t){return s(this,void 0,void 0,(function*(){let s=null,o=!1,i={},r=0,u=(e,n,t,s)=>{e in i||(i=this.initAuthor(e,i)),s?i[e].openAuthorIssues++:i[e].openAssignIssues++,n&&i[e].staleIssues++,t&&i[e].oldIssues++};do{let i=yield e.graphql({query:'\n    query updatedIssues($issuePagination: String) {\n      search(query: "org:1712n is:issue state:open", type: ISSUE, first: 25, after: $issuePagination) {\n          pageInfo {\n            startCursor\n            hasNextPage\n            endCursor\n          }\n        edges {\n          node {\n            ... on Issue {\n              updatedAt\n              author {\n                login\n              }\n              assignees(first: 20) {\n                nodes {\n                  login\n                }\n              }\n            }\n          }\n        }\n      }\n    }',issuePagination:s});i.search.edges.forEach((e=>{let s=e.node,o=s.author.login,i=s.assignees.nodes.map((e=>e.login)),r=(new Date).getTime()-Date.parse(s.updatedAt),a=r>1e3*n*60*60*24,l=r>1e3*t*60*60*24;u(o,a,l,!0),i.forEach((e=>{u(e,a,l,!1)}))})),i.search.pageInfo.hasNextPage?s=i.search.pageInfo.endCursor:o=!0,r+=i.search.edges.length}while(!o);return console.log(`Open Issues statistics processed ${r} issues`),i}))}pullCloseIssuesActivity(e,n,t){return s(this,void 0,void 0,(function*(){let s=null,o=!1,i={};const r=`\n    query updatedIssues($issuePagination: String) {\n      search(query: "org:1712n is:issue closed:${n.toISOString().substring(0,19)}..${t.toISOString().substring(0,19)}", type: ISSUE, first: 25, after: $issuePagination) {\n          pageInfo {\n            startCursor\n            hasNextPage\n            endCursor\n          }\n        edges {\n          node {\n            ... on Issue {\n              author {\n                login\n              }\n              assignees(first: 20) {\n                nodes {\n                  login\n                }\n              }\n              timelineItems(last: 10, itemTypes: [CLOSED_EVENT]) {\n                nodes{\n                  __typename\n                  ... on ClosedEvent {\n                    actor {\n                      login\n                    }\n                    createdAt\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }`;let u=0;do{let a=yield e.graphql({query:r,issuePagination:s});a.search.edges.forEach((e=>{let s=e.node,o=s.author.login,r=s.assignees.nodes.map((e=>e.login));s.timelineItems.nodes.forEach((e=>{let s=e.actor.login,u=Date.parse(e.createdAt);u<n.getTime()||u>t.getTime()||(s in i||(i=this.initAuthor(s,i)),o==s?i[s].closedSelfIssues++:r.includes(s)&&i[s].closedNotSelfIssues++)}))})),a.search.pageInfo.hasNextPage?s=a.search.pageInfo.endCursor:o=!0,u+=a.search.edges.length}while(!o);return console.log(`Closing Issues activity processed ${u} issues`),i}))}pullCommentsActivity(e,n,t){return s(this,void 0,void 0,(function*(){let s=null,o=null,i=!1,r={};const u=`\n    query updatedIssues($issuePagination: String, $commentPagination: String) {\n      search(query: "org:1712n is:issue updated:${n.toISOString().substring(0,19)}..${t.toISOString().substring(0,19)}", type: ISSUE, first: 1, after: $issuePagination) {\n          pageInfo {\n            startCursor\n            hasNextPage\n            endCursor\n          }\n        edges {\n          node {\n            ... on Issue {\n              closed\n              title\n              author {\n                login\n              }\n              assignees(first: 20) {\n                nodes {\n                  login\n                }\n              }\n              timelineItems(last: 10, itemTypes: [CLOSED_EVENT]) {\n                nodes{\n                  __typename\n                  ... on ClosedEvent {\n                    actor {\n                      login\n                    }\n                    createdAt\n                  }\n                }\n              }\n              comments (last: 10, before: $commentPagination) {\n                nodes {\n                  author {\n                    login\n                  }\n                  createdAt\n                }\n                pageInfo {\n                  startCursor\n                  hasPreviousPage\n                }\n              }\n            }\n          }\n        }\n      }\n    }`;let a=0;do{let l=yield e.graphql({query:u,issuePagination:s,commentPagination:o});l.search.edges.forEach((e=>{let s=e.node,o=s.author.login,i=s.assignees.nodes.map((e=>e.login));s.comments.nodes.forEach((e=>{let s=e.author.login,u=Date.parse(e.createdAt);u<n.getTime()||u>t.getTime()||(s in r||(r=this.initAuthor(s,r)),s==o||i.includes(s)?r[s].selfComments++:r[s].notSelfComments++)}))})),l.search.edges[0].node.hasPreviousPage?o=l.search.edges[0].node.startCursor:(l.search.pageInfo.hasNextPage?s=l.search.pageInfo.endCursor:i=!0,a++)}while(!i);return console.log(`Issues Activity processed ${a} issues`),r}))}pullAllUsersActivity(e,n,t){return s(this,void 0,void 0,(function*(){let s=[],o=null,i=!1,r=null;do{r=yield e.graphql({query:"query ($org: String! $orgid: ID $cursorID: String $from: DateTime, $to: DateTime) {\n      organization(login: $org ) {\n        membersWithRole(first: 25, after: $cursorID) {\n          nodes {\n            login\n            contributionsCollection (organizationID: $orgid, from: $from, to: $to) {\n              totalCommitContributions\n              totalIssueContributions\n              totalPullRequestContributions\n              pullRequestReviewContributionsByRepository(maxRepositories: 100) {\n                contributions {\n                  totalCount\n                }\n              }\n            }\n          }\n          pageInfo {\n            hasNextPage\n            endCursor\n          }\n        }\n        \n      }\n    }",org:this.org,orgid:this.orgID,from:n,to:t,cursorID:o});const u=r.organization.membersWithRole.nodes;i=r.organization.membersWithRole.pageInfo.hasNextPage;for(const e of u)o=i?r.organization.membersWithRole.pageInfo.endCursor:null,s.push({Member:e.login,CommitsCreated:e.contributionsCollection.totalCommitContributions,IssuesCreated:e.contributionsCollection.totalIssueContributions,PullRequestsOpened:e.contributionsCollection.totalPullRequestContributions,PullRequestsReviewed:e.contributionsCollection.pullRequestReviewContributionsByRepository.reduce((e=>e.contributions?e.contributions.totalCount:0),0),From:n.toISOString().substring(0,19),To:t.toISOString().substring(0,19),ClosedNotSelfIssues:0,ClosedSelfIssues:0,CodeLinesAdded:0,CodeLinesRemoved:0,CommentsInNotSelfIssues:0,CommentsInOpenedAssignedIssues:0,OldIssues:0,OpenIssuesAssign:0,OpenIssuesAuthor:0,StaleIssues:0})}while(i);return console.log(`All Users Activity processed ${s.length} users`),s}))}pullOrgID(e){return s(this,void 0,void 0,(function*(){let n=yield e.graphql({query:"query ($org: String!) {\n      organization(login: $org) {\n        id\n      }\n    }",org:this.org});this.orgID=n.organization.id}))}scrape(e,n,t,i){return s(this,void 0,void 0,(function*(){const s=new o.Octokit({auth:this.github_token});yield this.pullOrgID(s);let[r,u,a,l,c]=yield Promise.all([this.pullAllUsersActivity(s,e,n),this.pullCommitsStatistics(s,e,n),this.pullCommentsActivity(s,e,n),this.pullCloseIssuesActivity(s,e,n),this.pullOpenIssuesStatistics(s,t,i)]);return r.map((e=>{let n=e.Member;return n in u&&(e.CodeLinesAdded=u[n].codeLinesAdded,e.CodeLinesRemoved=u[n].codeLinesRemoved),n in a&&(e.CommentsInNotSelfIssues=a[n].notSelfComments,e.CommentsInOpenedAssignedIssues=a[n].selfComments),n in l&&(e.ClosedSelfIssues=l[n].closedSelfIssues,e.ClosedNotSelfIssues=l[n].closedNotSelfIssues),n in c&&(e.OpenIssuesAuthor=c[n].openAuthorIssues,e.OpenIssuesAssign=c[n].openAssignIssues,e.StaleIssues=c[n].staleIssues,e.OldIssues=c[n].oldIssues),e}))}))}}},999:e=>{e.exports=require("@actions/core")},142:e=>{e.exports=require("@octokit/core")},336:e=>{e.exports=require("aws-sdk")},917:e=>{e.exports=require("objects-to-csv")}},n={},t=function t(s){var o=n[s];if(void 0!==o)return o.exports;var i=n[s]={exports:{}};return e[s].call(i.exports,i,i.exports,t),i.exports}(341);for(var s in t)this[s]=t[s];t.__esModule&&Object.defineProperty(this,"__esModule",{value:!0})})();